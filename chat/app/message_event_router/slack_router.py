import logging
from datetime import datetime
from typing import List

from fastapi import status

from config import settings
from slack_sdk.web.async_client import AsyncWebClient
import requests

log = logging.getLogger(__name__)


class SlackRouter:

    _webclient: AsyncWebClient = AsyncWebClient(token=settings.slack_bot_user_token)

    @staticmethod
    async def route_new_message(event: dict, **kwargs) -> None:
        """
        TODO see blocks in event for urls
        """
        log.info(f"Routing event {event} with kwargs {kwargs}")
        message_event = event["event"]

        posting_user = message_event.get("user")
        channel = message_event["channel"]
        post_time = datetime.fromtimestamp(float(message_event["ts"]))
        message_text = message_event["text"]
        event_type = message_event.get("type")

        if event_type != "message":
            log.warning(f"Got event of type {event_type}, ignoring event")
            return

        if subtype := message_event.get("subtype") and posting_user is None:
            log.warning(f"Event of subtype {subtype} received with no user. Ignoring.")
            return

        # TODO get bt ID during init from a test call.
        if (bot_id := message_event.get("bot_id")) == "BLU4X4KL5":
            log.info(f"Event generated by bot {bot_id}. Ignoring event")
            return

        if (urls := SlackRouter._extract_links(message_event)):
            await SlackRouter._post_url_analysis(channel, posting_user, urls)
            return

        resp = await SlackRouter._webclient.chat_postMessage(
            channel=channel,
            text=f"<@{posting_user}> you posted {message_text} at {post_time}.",
        )

        log.info(f"Response when sending {message_text} to user {posting_user}: {resp}")

    @staticmethod
    def _extract_links(message_event: dict) -> List[str]:
        """
        If there ar links present in the message event, extracts the URLs
        and takes the appropriate actions.

        Returns the number of links found.
        """
        block_elements = []
        urls: List[str] = list()
        try:
            # TODO add message payload fields documentation link
            block_elements = message_event["blocks"][0]["elements"][0]["elements"]
        except (IndexError, KeyError) as exp:
            log.error(f"Expecting to see links in message event but got {exp}")
            return urls

        for element in block_elements:
            if element.get("type") == "link":
                if url := element.get("url"):
                    urls.append(url)
        return urls

    @staticmethod
    async def _post_url_analysis(
        channel: str, posting_user: str, urls: List[str]
    ) -> bool:

        message = (
            f"{len(urls)} URL(s) were/was posted by <@{posting_user}>. Analysis status: TODO"
        )
        resp = await SlackRouter._webclient.chat_postMessage(
            channel=channel,
            text=message,
        )
        assert resp.get("ok"), f"Failed to send message {message} with error {resp}"

        scrape_url = "http://scrape:4001/api/extract/web"
        log.info(scrape_url)
        for url in urls:
            scrape_request = dict(
                url=url,
                tags=[posting_user, "slack_im_share"],
            )
            log.info(f"Contacting scrape on endpoint {scrape_url} with request payload {scrape_request}")

            response = requests.post(
                scrape_url,
                json=scrape_request
            )
            assert response.status_code == status.HTTP_200_OK, f"Invalid response from scrape {response} with content {response.text}"
            article = response.json()
            num_words = len(article["raw_text"].split())
            num_urls = len(article["nested_urls"])
            message = (
                f"{num_words} words in article with {num_urls} nested URLs"
            )
            resp = await SlackRouter._webclient.chat_postMessage(
                channel=channel,
                text=message,
            )
            assert resp.get("ok"), f"Failed to send message {message} with error {resp}"

        return True
